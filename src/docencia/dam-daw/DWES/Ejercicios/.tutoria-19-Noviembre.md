# Paso a paso para modificar el modelo de socios

Vamos a abordar cada necesidad de forma incremental, explicando las decisiones en cada paso.

## **Paso 1: Añadir tutores para socios menores de edad** (Necesidad A)

### Objetivo
Permitir que un socio menor de edad tenga uno o más tutores, guardando para cada tutor: dirección, DNI, nombre y apellidos.

### Decisiones clave:

1. **¿Modelo separado o campos en Socio?** Creo un modelo `Tutor` independiente porque:
   - Un tutor puede estar asociado a varios menores (hermanos)
   - Evita campos repetitivos en `Socio` (dni_tutor1, nombre_tutor1, etc.)
   - Es más mantenible y escalable

2. **¿Relación ManyToMany o OneToMany?** ManyToMany porque:
   - Un menor puede tener varios tutores (padre Y madre)
   - Un tutor puede tener varios menores a su cargo

3. **¿Dirección en Tutor o reutilizar Direccion?** Reutilizo el modelo `Direccion` existente con OneToOne porque:
   - Mantiene la consistencia con el modelo Socio
   - Permite que tutor y socio tengan direcciones diferentes
   - Aprovecha la validación existente

### Código añadido/modificado:

```python
class Tutor(models.Model):
    # Identificador único
    id = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4)
    
    # Datos personales del tutor
    nombre = models.CharField(max_length=100)
    apellidos = models.CharField(max_length=200)
    dni = models.CharField(max_length=9, unique=True)
    
    # Relación con dirección (un tutor vive en un solo lugar)
    direccion = models.OneToOneField(Direccion, on_delete=models.CASCADE, related_name='tutor')

    def __str__(self):
        return f"{self.nombre} {self.apellidos}"

# MODIFICACIÓN EN EL MODELO SOCIO
class Socio(models.Model):
    # ... (campos existentes)
    
    # Añadir esta relación después del campo menor_edad
    tutores = models.ManyToManyField(Tutor, blank=True, related_name='menores')
```

**Nota importante**: El campo `blank=True` permite que un socio mayor de edad no tenga tutores.

---

## **Paso 2: Identificar el método de pago** (Necesidad B)

### Objetivo
Los socios deben tener un campo que identifique si pagan por transferencia o domiciliación bancaria.

### Decisiones clave:

1. **¿Campo Booleano o Choice?** Uso `CharField` con `choices` porque:
   - Es más legible en la base de datos (`'transferencia'` vs `True/False`)
   - Facilita añadir métodos futuros (tarjeta, PayPal, etc.)
   - Los templates y admin muestran etiquetas claras

2. **¿Valor por defecto?** `'domiciliacion'` porque:
   - Es el método más común en asociaciones
   - Reduce la configuración inicial

3. **¿Dónde colocar el IBAN?** Mantengo el campo `IBAN` en Socio porque:
   - Aunque solo se use en domiciliación, puede ser útil tenerlo
   - Podría usarse para transferencias también
   - No justifica una relación separada

### Código añadido:

```python
class Socio(models.Model):
    # Choices definidos al principio de la clase
    METODO_PAGO_CHOICES = [
        ('transferencia', 'Transferencia'),
        ('domiciliacion', 'Domiciliación Bancaria'),
    ]
    
    # ... (otros campos)
    
    # Nuevo campo después de menor_edad
    metodo_pago = models.CharField(
        max_length=15, 
        choices=METODO_PAGO_CHOICES, 
        default='domiciliacion'
    )
    
    # Campo IBAN ya existente (sin cambios)
    IBAN = models.CharField(max_length=34, blank=True, null=True)
```

---

## **Paso 3: Autenticación y roles de usuario** (Necesidad C)

### Objetivo
Los socios se identifican por email/password (encriptado) y tienen rol ROOT, ADMIN o USER.

### Decisiones clave:

1. **¿Password en el modelo?** Uso `CharField(max_length=128)` porque:
   - Django almacena hashes (no texto plano) que pueden tener hasta 128 caracteres
   - **NO** guardo la contraseña en texto plano por seguridad
   - Recomiendo usar `make_password()` al crear usuarios

2. **¿Email como username?** Uso `EmailField(unique=True)` porque:
   - Es único por naturaleza
   - Facilita el login y recuperación de contraseña
   - Evita crear un campo `username` adicional

3. **¿Rol como Integer o Char?** `CharField` con choices porque:
   - Más legible en base de datos (`'ADMIN'` vs `1`)
   - No requiere joins o lookups adicionales
   - Fácil de filtrar: `Socio.objects.filter(rol='ADMIN')`

4. **¿Campo `menor_edad` sigue siendo necesario?** **NO** - Lo elimino porque:
   - Se puede calcular dinámicamente con `fecha_nacimiento`
   - Evita inconsistencias (campo desactualizado)
   - Creo un método `@property` en su lugar

### Código modificado:

```python
import uuid
from django.db import models
from datetime import date

class Socio(models.Model):
    # Choices para roles
    ROL_CHOICES = [
        ('ROOT', 'Root'),
        ('ADMIN', 'Administrador'),
        ('USER', 'Usuario'),
    ]
    
    # Campos básicos (modificados)
    id = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4)
    nombre = models.CharField(max_length=100)
    apellidos = models.CharField(max_length=200)
    fecha_nacimiento = models.DateField()
    telefono = models.CharField(max_length=9)  # Cambiado a CharField
    
    # Nuevos campos de autenticación
    email = models.EmailField(unique=True)  # Ya existía, ahora es clave de login
    password = models.CharField(max_length=128)  # Django almacenará el hash
    rol = models.CharField(max_length=5, choices=ROL_CHOICES, default='USER')
    
    fecha_registro = models.DateTimeField(auto_now_add=True)
    metodo_pago = models.CharField(max_length=15, choices=[...], default='domiciliacion')
    IBAN = models.CharField(max_length=34, blank=True, null=True)
    documento_identidad = models.CharField(max_length=9, unique=True, null=True)
    
    direccion = models.OneToOneField(Direccion, on_delete=models.CASCADE, related_name='socio')
    tutores = models.ManyToManyField(Tutor, blank=True, related_name='menores')

    # Método para calcular si es menor de edad
    @property
    def es_menor(self):
        hoy = date.today()
        edad = hoy.year - self.fecha_nacimiento.year - (
            (hoy.month, hoy.day) < (self.fecha_nacimiento.month, self.fecha_nacimiento.day)
        )
        return edad < 18

    def __str__(self):
        return f"{self.nombre} {self.apellidos}"
```

---

## **Paso 4: Crear el modelo de Pago** (Necesidad D)

### Objetivo
Registrar pagos con mes/año, estado, fecha de completado, archivo de verificación (si es transferencia) y admin validador.

### Decisiones clave:

1. **¿Modelo propio o en Socio?** Modelo apartado `Pago` porque:
   - Un socio tiene múltiples pagos (uno por mes/año)
   - Evita campos repetitivos en Socio
   - Permite queries eficientes: `Pago.objects.filter(estado='pendiente')`

2. **¿Mes y año separados?** Sí, porque:
   - Facilita filtrar por mes o año independientemente
   - Evita parsear fechas
   - Permite pagos planificados futuros

3. **¿Estado como Boolean?** `CharField` con 3 opciones porque:
   - Necesitamos: pendiente/devuelto/completado
   - Boolean solo permite 2 estados

4. **¿Archivo de verificación?** `FileField` porque:
   - Puede ser imagen (captura) o PDF (justificante)
   - `upload_to` organiza archivos por fecha
   - Solo obligatorio si método es transferencia

5. **¿Validador?** `ForeignKey` a Socio con `limit_choices_to` porque:
   - Solo usuarios ADMIN pueden validar
   - Django admin aplica el filtro automáticamente
   - `SET_NULL` si se elimina el admin (histórico)

### Código completo del modelo:

```python
class Pago(models.Model):
    # Choices
    MES_CHOICES = [(i, i) for i in range(1, 13)]  # Lista de tuplas (1,1), (2,2)...
    
    ESTADO_CHOICES = [
        ('pendiente', 'Pendiente'),
        ('completado', 'Completado'),
        ('devuelto', 'Devuelto'),
    ]

    # Identificador único
    id = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4)
    
    # Relación con el socio que paga
    socio = models.ForeignKey(Socio, on_delete=models.CASCADE, related_name='pagos')
    
    # Mes y año del pago
    mes = models.IntegerField(
        choices=MES_CHOICES, 
        validators=[MinValueValidator(1), MaxValueValidator(12)]
    )
    anio = models.IntegerField(validators=[MinValueValidator(2000)])
    
    # Estado y fecha
    estado = models.CharField(max_length=10, choices=ESTADO_CHOICES, default='pendiente')
    fecha_completado = models.DateTimeField(null=True, blank=True)
    
    # Campos específicos para transferencias
    archivo_verificacion = models.FileField(
        upload_to='pagos/verificaciones/%Y/%m/',  # Organiza por año/mes
        null=True, 
        blank=True
    )
    
    # Admin que validó el pago
    validado_por = models.ForeignKey(
        Socio, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        limit_choices_to={'rol': 'ADMIN'},  # Solo usuarios ADMIN
        related_name='pagos_validados'  # Para acceder desde Socio: socio.pagos_validados.all()
    )

    class Meta:
        # Un socio solo puede tener un pago por mes/año
        unique_together = ['socio', 'mes', 'anio']
        # Ordenar por año y mes descendente
        ordering = ['-anio', '-mes']

    def __str__(self):
        return f"Pago {self.mes}/{self.anio} - {self.socio} ({self.estado})"
```

# Vistas

Tienes toda la razón, **asumí autenticación sin que lo solicitaras**, lo cual es un error mío. Me dejé llevar por las buenas prácticas de seguridad habituales, pero tu indicación es clara: **"por ahora no vamos a usar autenticación"**.

## ¿Por qué lo usé originalmente?

`LoginRequiredMixin` y `UserPassesTestMixin` son mixins de Django que:
- **Obligan al usuario a estar logueado** para ver la vista (si no, redirigen al login)
- **Filtran permisos por objeto** (ej: solo el propio socio o un admin pueden ver sus datos)

Los usé por inercia porque **es la forma estándar y segura** de construir vistas en Django que manejan datos sensibles (DNI, IBAN, pagos). Pero en tu caso, **es totalmente innecesario** si no hay sistema de login aún.

---

## **Código CORREGIDO sin autenticación**

Aquí están las **tres vistas limpias**, sin mezclar autenticación:

### **Vista 1: Detalle de socio con tutores**

```python
# views.py
from django.views.generic import DetailView
from .models import Socio

class SocioDetailView(DetailView):
    model = Socio
    template_name = 'socios/socio_detail.html'
    context_object_name = 'socio'
    
    def get_queryset(self):
        # Solo precargamos datos relacionados (sin restricciones de acceso)
        return Socio.objects.prefetch_related('tutores', 'direccion')
```

**URL:**
```python
path('socio/<uuid:pk>/', views.SocioDetailView.as_view(), name='socio-detail'),
```

---

### **Vista 2: Pagos del año actual**

```python
# views.py
from django.utils import timezone
from django.views.generic import DetailView

class SocioPagosAnioView(DetailView):
    model = Socio
    template_name = 'socios/socio_pagos_anio.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        anio_actual = timezone.now().year
        
        # Todos los pagos del año actual (sin filtrar por usuario)
        pagos = self.object.pagos.filter(
            anio=anio_actual
        ).order_by('mes')
        
        context['pagos_anio'] = pagos
        context['anio_actual'] = anio_actual
        
        return context
```

**URL:**
```python
path('socio/<uuid:pk>/pagos/', views.SocioPagosAnioView.as_view(), name='socio-pagos-anio'),
```

---

### **Vista 3: Listado de deudas**

```python
# views.py
from django.views.generic import ListView
from django.db.models import Prefetch
from datetime import datetime

class SociosDeudaListView(ListView):
    model = Socio
    template_name = 'socios/socio_list_deuda.html'
    context_object_name = 'socios'
    
    def get_queryset(self):
        # Todos los socios, sin restricciones
        return Socio.objects.prefetch_related(
            Prefetch('pagos', queryset=Pago.objects.all())
        )
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        ahora = datetime.now()
        mes_actual = ahora.month
        anio_actual = ahora.year
        
        socios_data = []
        for socio in context['socios']:
            pagos_deuda = socio.pagos.filter(
                Q(anio__lt=anio_actual) | 
                Q(anio=anio_actual, mes__lt=mes_actual),
                estado__in=['pendiente', 'devuelto']
            )
            
            meses_deuda = pagos_deuda.count()
            total_deuda = meses_deuda * socio.cuota_mensual
            
            socios_data.append({
                'socio': socio,
                'al_dia': meses_deuda == 0,
                'deuda_meses': meses_deuda,
                'total_deuda': total_deuda,
            })
        
        context['socios_data'] = socios_data
        context['mes_actual'] = mes_actual
        context['anio_actual'] = anio_actual
        
        return context
```

**URL:**
```python
path('socios/deuda/', views.SociosDeudaListView.as_view(), name='socios-deuda'),
```

# Refactorización para crear servicios

## **Paso 1: Crear la clase de servicios `SociosServices`**

Creamos un archivo dedicado `services.py` al nivel de la app `socios`:

```python
# socios/services.py
from datetime import datetime
from django.db.models import Q
from .models import Socio, Pago

class SocioService:
    """
    Servicio central para la lógica de negocio de socios.
    """
    
    @staticmethod
    def calcular_deuda(socio, fecha_corte=None):
        """
        Calcula la deuda de un socio hasta una fecha específica.
        
        Args:
            socio: Instancia de Socio
            fecha_corte: Fecha de referencia. Si es None, usa mes anterior al actual.
        
        Returns:
            dict: {'meses': int, 'total': Decimal, 'al_dia': bool}
        """
        if fecha_corte is None:
            fecha_corte = datetime.now()
        
        # Fecha de corte: meses ANTERIORES a esta fecha
        mes_corte = fecha_corte.month
        anio_corte = fecha_corte.year
        
        # Si es Enero, mes anterior es Diciembre del año anterior
        if mes_corte == 1:
            mes_anterior = 12
            anio_anterior = anio_corte - 1
        else:
            mes_anterior = mes_corte - 1
            anio_anterior = anio_corte
        
        # Filtrar pagos pendientes/devueltos de meses previos
        pagos_deuda = socio.pagos.filter(
            Q(anio__lt=anio_corte) |  # Todos los años anteriores
            Q(anio=anio_corte, mes__lt=mes_corte),  # Meses anteriores del año actual
            estado__in=['pendiente', 'devuelto']
        )
        
        meses_deuda = pagos_deuda.count()
        total_deuda = meses_deuda * socio.cuota_mensual
        
        return {
            'meses': meses_deuda,
            'total': total_deuda,
            'al_dia': meses_deuda == 0
        }
    
    @staticmethod
    def generar_pagos_mensuales(mes=None, anio=None):
        """
        Genera registros de pago mensuales para TODOS los socios.
        Se ejecuta el día 1 de cada mes (desde task manager).
        
        Args:
            mes: Mes a generar (1-12). None = mes actual
            anio: Año a generar. None = año actual
        
        Returns:
            int: Número de pagos creados
        """
        if mes is None or anio is None:
            ahora = datetime.now()
            mes = ahora.month
            anio = ahora.year
        
        socios = Socio.objects.all()
        pagos_creados = 0
        
        for socio in socios:
            # get_or_create evita duplicados si se ejecuta por error 2 veces
            pago, creado = Pago.objects.get_or_create(
                socio=socio,
                mes=mes,
                anio=anio,
                defaults={
                    'estado': 'pendiente',
                    # No asignamos validador porque aún no está validado
                }
            )
            
            if creado:
                pagos_creados += 1
        
        return pagos_creados
```

## **Paso 2: Refactorizar la vista de deudas**

Ahora la vista `SociosDeudaListView` queda **dramáticamente más simple**:

```python
# socios/views.py
from django.views.generic import ListView
from django.db.models import Prefetch
from .models import Socio, Pago
from .services import SocioService

class SociosDeudaListView(ListView):
    model = Socio
    template_name = 'socios/socio_list_deuda.html'
    context_object_name = 'socios'
    
    def get_queryset(self):
        # Precargamos pagos para evitar N+1 en el servicio
        return Socio.objects.prefetch_related(
            Prefetch('pagos', queryset=Pago.objects.all())
        )
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Usamos el servicio para cada socio
        socios_data = []
        for socio in context['socios']:
            deuda_info = SocioService.calcular_deuda(socio)
            
            socios_data.append({
                'socio': socio,
                **deuda_info  # Expande 'al_dia', 'meses', 'total'
            })
        
        context['socios_data'] = socios_data
        context['mes_actual'] = datetime.now().month
        context['anio_actual'] = datetime.now().year
        
        return context
```

## **Paso 3: Preparar el task manager**

Para ejecutar `generar_pagos_mensuales` el día 1 del mes, creamos un **management command** (compatible con cron, Celery, Django-Q...):

```python
# socios/management/commands/generar_pagos_mensuales.py
from django.core.management.base import BaseCommand
from socios.services import SocioService

class Command(BaseCommand):
    help = 'Genera pagos mensuales para todos los socios (ejecutar día 1)'
    
    def add_arguments(self, parser):
        # Permite forzar mes/año manualmente
        parser.add_argument('--mes', type=int, help='Mes específico (1-12)')
        parser.add_argument('--anio', type=int, help='Año específico')
    
    def handle(self, *args, **options):
        mes = options.get('mes')
        anio = options.get('anio')
        
        try:
            pagos_creados = SocioService.generar_pagos_mensuales(mes=mes, anio=anio)
            self.stdout.write(
                self.style.SUCCESS(f'✅ Pagos generados exitosamente: {pagos_creados}')
            )
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'❌ Error: {str(e)}')
            )
```

### **Ejemplos de uso:**

**Desde cron (recomendado):**
```bash
# Crontab que se ejecuta el día 1 a las 02:00 AM
0 2 1 * * cd /ruta/al/proyecto && python manage.py generar_pagos_mensuales
```

**Desde Celery Beat:**
```python
# proyecto/celery.py
from celery import shared_task
from socios.services import SocioService

@shared_task
def tarea_pagos_mensuales():
    # Celery Beat configurado para ejecutar este task día 1
    SocioService.generar_pagos_mensuales()
```

**Manual (para pruebas):**
```bash
python manage.py generar_pagos_mensuales --mes=6 --anio=2024
```

---

## **Paso 4: Beneficios de este diseño**

| Antes (lógica en vista) | Ahora (servicios) |
|-------------------------|-------------------|
| Código mezclado | Separación de responsabilidades |
| Difícil de testear | Test unitario simple: `test_calcular_deuda()` |
| No reutilizable | Reutilizable en admin, API, comandos |
| Acoplado a HTTP | Independiente de Django (puro Python) |
| Lento en debug | Optimizable en un solo lugar |

**Ejemplo de test unitario:**
```python
# tests/test_services.py
from django.test import TestCase
from socios.services import SocioService
from socios.models import Socio

class SocioServiceTest(TestCase):
    def test_socio_al_dia(self):
        socio = Socio.objects.create(...)
        # Creamos pagos completados...
        resultado = SocioService.calcular_deuda(socio)
        self.assertTrue(resultado['al_dia'])
```

